## Redis的分布式锁
在许多环境中，进程之间必须以排它的方式访问共享资源，此时，分布式锁就成为了一项有用且必要的功能。

目前，许多的库及博客文章都有介绍如何在现有Redis之上，实现一个DLM(分布式锁管理器)。但在实现方法上，有些简单，有些复杂，而前者还不够完备，无法保证可靠性。

本文作为一次尝试，提供一种更为通用、规范的算法，叫做**RedLock**，实现上述的DLM(分布式锁)。我们相信它会比仅依赖单台Redis实现的锁，更为完备和安全。希望在这个社区中，能收到更多针对此实现方法试用分析后的反馈。这将会是一个好的开始。

#### 相关实现
在具体介绍该算法之前，这儿有几个链接，供您参考。
  * [RedLock-cpp](https://github.com/jacket-code/redlock-cpp)(C++ 实现)
  * [Redisson](https://github.com/mrniko/redisson)(java 实现)
  * [Redsync.go](https://github.com/hjr265/redsync.go)(Go 实现)

#### 安全性及可持续性原则
我们给出的方法基于以下三个原则。
因为我们认为，这三个原则是实现一个高性能的分布式锁的最低保证。
1. 安全性原则: 保证排它性。在任意时候，仅有一个客户进程持有锁。
2. 持续性原则A：保证无死锁。即使占有锁的客户端崩溃或者发生网络分区
3. 持续性原则B：保证容错性。只要**多数**的Redis节点正常运行着，客户端便能够获取/释放锁。

#### 仅基于故障切换(failover-based)的方案是不够的
知己知彼才能百战不殆，先一起来看一下目前大多数基于Redis的分布式锁库的现状。对一个资源用Redis实现加锁，最简单的方法就是在一个实例里，创建一个键(Key)。利用Redis自带的超时特性，使得创建出来的键一般都有一个有限的存活时间，从而保证了锁能最终能被释放掉(以下列表的第二点)。当客户端需要释放掉这个资源时，删掉创建的键(Key)即可。

表面上看来，一切都是正常的，实则不然，例如，我们的架构中，存在一个单点故障(a single point of failure)，如果Master节点宕掉了，通常会出现什么后果？那么好吧，我们给Master添加一个slave节点，这么一来，一旦Master节点不可用时，切换到Slave节点就行了。然而很不幸，这依然行不通。因为一旦这么做，就无法保证上述第1点————排他性，因为Redis的主备复制操作是异步完成的。

在这个方案(model)里，有一个明显的竞争条件：
1. 客户端A在Master节点拿到了锁；
2. 创建的Key在被写入到Slave之前，Master宕掉了；
3. 那么，Slave就晋升为Master了；
4. 客户端B拿到了与A持有的针对相同资源的锁。
这么一来，就违背安全性原则(safety property)。

当然了，在一些特殊的情况下，这种方法也完全可行。例如在宕机期间，多个客户端可以允许持有相同的锁。如果是这样，上述基于复制的解决方案自然没问题。否则的话，建议用本文的方案。

#### 结合单例正确的实现
在尝试克服掉上述单例存在的这种不足之前，先一起看下是否有办法修复它。因为在不时可以接受竞争条件的应用中，这是一种切实可行的解决方案。而且对于分布式算法，利用单实例的锁策略，是这篇文章的将要描述的基础。

得到这个锁，用下面的命令：

    SET resource_name my_random_value NX PX 30000    
在这里解释一下(以下的几点，引自左耳朵耗子)
  * SET NX 只会在key不存在的时候，给key赋值，PX命令是通知Redis保存这个key值30000ms
  * my_random_value 是一个全局唯一的值，并且必须是全局唯一。这个随机数在释放锁是保证释放锁操作的安全性。
  * PX 30000 后面的参数指代key的存活时间，记作锁过期时间
  * 当资源被锁定，超过了这个时间(这里的话，这个时间是30000ms)，锁将被自动释放。
  * 获得锁的客户端，如果没有在这个时间窗口内完成操作，就有可能由其它客户端获得该锁，引起竞争。
根据这个解释，那么上面的命令的意思就是当且仅当键(key)不存在的时候(NX选项的意思)，设置键(key)的值，并且超时时间定为30000ms(PX选项的作用)。这 个键的值被设为"my\_random\_value"。必须保证该值的全局唯一性，即对所有锁请求的客户端里。基本上使用这个随机值用以保证锁能被以安全的方式释放。利用Lua脚本告知Redis：删除这个键(key)当且仅当该键存在，且与该键对应的值正是所预期的。脚本命令见下：
\\\\\\\

       if redis.call("get", KEYS[1]) == ARGV[1] then
           return redis.call("del", KEYS[1])
       else
           return 0;
       end
    
这很重要的，可以避免误删由其它客户端创建的锁。举例来说，一个客户端可能拿到了锁，在某些操作中，进入阻塞状态的持续时间超过了指定给锁的有效时长(此时，这个键将过期)，并在之后删除了这个锁，然而另一个客户端已经取得了这个锁。因此，仅使用DEL命令并不安全，因为存在误删，导致一个客户端删除了另一个客户端正在持有的锁。所以，使用一个随机的字符串"标记"每一个锁，替代上面的Lua脚本，这么一来，一个客户端删除锁时，只有确定了值是由自己设定的，才能将删除锁的操作执行成功。









