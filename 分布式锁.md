## Redis的分布式锁
在许多环境中，进程之间必须以排它的方式访问共享资源，此时，分布式锁就成为了一项有用且必要的功能。

目前，许多的库及博客文章都有介绍如何在现有Redis之上，实现一个DLM(分布式锁管理器)。但在实现方法上，有些简单，有些复杂，而前者还不够完备，无法保证可靠性。

本文作为一次尝试，提供一种更为通用、规范的算法，叫做**RedLock**，实现上述的DLM(分布式锁)。我们相信它会比仅依赖单台Redis实现的锁，更为完备和安全。希望在这个社区中，能收到更多针对此实现方法试用分析后的反馈。就这个方法而言，将会是一个好的开始。

##### 相关实现
在具体介绍该算法之前，这儿有几个链接，供您参考。
  * [RedLock-cpp](https://github.com/jacket-code/redlock-cpp)(C++ 实现)
  * [Redisson](https://github.com/mrniko/redisson)(java 实现)
  * [Redsync.go](https://github.com/hjr265/redsync.go)(Go 实现)

##### 安全性及可持续性原则
我们给出的方法基于以下三个原则。
因为我们认为，这三个原则是实现一个高性能的分布式锁的最低保证。
1. 安全性原则: 保证排它性。在任意时候，仅有一个客户进程持有锁。
2. 持续性原则A：保证无死锁。即使占有锁的客户端崩溃或者与服务端断连接，也总能够正常的释放掉锁。
3. 持续性原则B：保证容错性。只要**多数**的Redis节点正常运行着，客户端便能够获取/释放锁。


