## Redis的分布式锁
在许多环境中，进程之间必须以排它的方式访问共享资源，此时，分布式锁就成为了一项有用的技术手段。

目前，许多第三方库及博客文章都有介绍如何在现有Redis之上，实现一个DLM(分布式锁管理器)。但在实现方法上，有些简单，有些复杂，而前者还不够完备，无法保证可靠性。

本文作为一次尝试，提供一种更为通用、规范的算法，叫做**RedLock**，实现上述的DLM(分布式锁)。我们相信它会比仅依赖单台Redis实现的锁，更为完备和安全。希望在这个社区中，该算法能够得到充分的分析，然后将分析结果向我们反馈。依据反馈，我们也努力的让这个算法变得更健壮，亦或者我们可以以此为依据，设计全新的算法。

#### 相关实现
在具体介绍该算法之前，这儿有几个链接，供您参考。
  * [RedLock-cpp](https://github.com/jacket-code/redlock-cpp)(C++ 实现)
  * [Redisson](https://github.com/mrniko/redisson)(java 实现)
  * [Redsync.go](https://github.com/hjr265/redsync.go)(Go 实现)

#### 安全性及可持续性原则
我们给出的方法基于以下三个原则。
因为我们认为，这三个原则是实现一个高性能的分布式锁的最低保证。
1. 安全性原则: 保证排它性。在任意时候，仅有一个客户进程持有锁。
2. 持续性原则A：保证无死锁。即使占有锁的客户端崩溃或者发生网络分区
3. 持续性原则B：保证容错性。只要**多数**的Redis节点正常运行着，客户端便能够获取/释放锁。

#### 仅基于故障切换(failover-based)的方案是不够的
为了弄明白我们想要提高的是什么，先看一下目前大多数基于Redis的分布式锁第三方库的现状。对一个资源用Redis实现加锁，最简单的方法就是在一个实例里，创建一个Key。利用Redis自带的超时特性，使得创建出来的Key一般都有一个有限的存活时间，从而保证了锁能最终能被释放掉(以下列表的第二点)。当客户端需要释放掉这个锁时，删掉创建的Key即可。

单从表面上看来，这一切似乎都是正常的，实则不然。例如，在我们的架构中，存在一个单点故障(a single point of failure)的问题，如果Master节点宕掉了，该怎么办呢？可能有人会说，给Master添加一个slave节点不就行了。这样，当Master节点不可用时，可以切换到Slave。然而很不幸，这种方法依然行不通。因为这么做，违背了上述第1点————排他性，你要知道，Redis的主备复制操作是异步进行的。

在这个方案(model)里，有一个明显的竞争条件：
1. 客户端A在Master节点拿到了锁；
2. 创建的Key在被写入到Slave之前，Master宕掉了；
3. 那么，Slave就晋升为Master了；
4. 客户端B拿到了与A持有的针对相同资源的锁。
这么一来，就违背安全性原则(safety property)。

当然了，在一些特殊的情况下，这种方法也完全可行。例如在宕机期间，多个客户端可以允许持有相同的锁。如果是这样，上述基于复制的解决方案自然没问题。否则的话，建议用本文的方案。

#### 结合单实例的正确实现
在尝试克服掉上述单实例存在的不足之前，先一起看下是否有什么办法，可以修复它。因为在可以容忍竞争条件的应用中，这是一种切实可行的解决方案。而且对于分布式算法，利用单实例的锁策略去实现，是这篇文章的将要描述的算法的基础。

得到这个锁，用下面的命令：

    SET resource_name my_random_value NX PX 30000    
在这里解释一下
  * SET NX 只会在key不存在的时候，给key赋值，PX命令是通知Redis保存这个key值30000ms
  * my_random_value 是一个全局唯一的值，并且必须是全局唯一。这个随机数在释放锁时保证释放锁操作的安全性。
  * PX 30000 后面的参数指代key的存活时间，记作锁过期时间
  * 当资源被锁定，超过了这个时间(这里的话，这个时间是30000ms)，锁将被自动释放。
  * 获得锁的客户端，如果没有在这个时间窗口内完成操作，就有可能由其它客户端获得该锁，引起竞争。
根据这个解释，那么上面的命令的意思就是当且仅当键(key)不存在的时候(NX选项的意思)，设置键(key)的值，并且超时时间定为30000ms(PX选项的作用)。这 个键的值被设为"my\_random\_value"。必须保证该值的全局唯一性，即对所有锁请求的客户端里。基本上使用这个随机值用以保证锁能被以安全的方式释放。利用Lua脚本告知Redis：删除这个键(key)当且仅当该键存在，且与该键对应的值正是所预期的。

脚本命令见下。

    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0;
    end
    
这很重要的，能够避免锁的误删。举例来说，一个客户端可能拿到了锁，因为当中的某个操作而被阻塞，持续的时间超过了指定的有效时长(此时，这个键将过期)后，这个客户端尝试删除这个锁，然而这个锁已被另一个客户端占有。因此，仅使用DEL指令并不安全，很可能导致一个客户端删除了另一个客户端正在持有的锁。上面的Lua脚本示例可以看出，每个客户端对应的锁都用一个随机字符串进行过"签名"，如果要删除锁，只有对应的客户端才可以做到，这就保证了删除锁时候的安全性。

那应当怎样生成这个随机字符串呢？在这里，假设是从 /dev/urandom生成的20个字节大小的随机字符串。当然啦，你可以找到更为高效的方法，确保这个随机字符串的唯一性。例如可以对/dev/urandom使用RC4加密算法，生成一个伪随机流。另一个更简单的方法就是用带毫秒的UNIX时间戳接上客户的ID，这也并不安全，但在大部分环境中，其安全性已经足够了。

键存活时间，也称"锁有效时间"。既是锁自动释放的时间，也是一个客户端的锁在被其它客户端抢占之前，可以执行必要任务的时间。严格来说，在不违背排他性原则的前提下，这个时间仅限于客户端从拿到锁的那一刻起，一个给定的窗口时间。

故现在，我们有一个能够拿到/释放锁的好方法，这对一个单机的、永不宕机的系统来说，能够保证锁的安全性。但如果把这个方法运用到分布式系统当中，就无法保证这一点了。

#### RedLock算法
在这个算法的分布式版本中，我们假定有N个Redis master节点，并且这些节点之间完全独立。没有任何复制或隐式协调操作被应用在节点之间。前面，已经详述了单实例情形下，如何安全地获取/释放锁。因此在Red Lock算法中，同样在单实例的情况下进行获取/释放锁，没有理由不使用这个方法。例如，我们让N = 5，这是一个合理的值，意味着5个Redis master节点在不同的计算机或虚拟机上运行。以此确保在大部分情况下，它们以独立的方式失败(言外之意，就是大多数Master正常运行着)。

要成功获取锁，一个客户端须执行以下操作：
1. 获取当前时间，精确到毫秒；
2. 在这N个节点上，尝试使用相同的键名称和随机值依次获取锁。在这一步执行期间，当客户端在每一个节点(实例)中都设置锁时，使用了一个比*总的锁自动释放时间*(the total lock auto-release time)要小很多的超时时间来取得锁。就比如，如果总的锁自动释放时间被定位10s，那么这个超时时间就被定在大概5-50ms的范围里。这种策略可以防止客户端在一个已经宕掉的Redis节点上，阻塞太长的时间。如果一个节点(实例)不可用，应当尽快尝试下一个节点(实例)。
3. 客户端使用当前时间减去在第1步时取得的时间戳，来计算成功获取到锁需要花费的时间。当且仅当，这个客户端能够在大多数的实例(至少3个实例)中，取得锁，并且所消耗的总时间必须小于锁的有效时间。只有这样，才被认定为客户端成功取得了锁。
4. 锁一旦被获取到，其有效时常为该锁初始的有效时间减去为取得该锁耗费的时间。
5. 如果因为某些原因(要么是未能在至少3(5/2 + 1)个实例中成功获取锁，要么是获取锁耗费的时间大于锁自动释放的时间)，这个客户端未能获取到锁，它都会到每个节点(实例)上，尝试释放锁，哪怕是那些它认为没有成功获取的锁。








